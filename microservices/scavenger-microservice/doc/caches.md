# Caches

This page lists the remote cache (from Infinispan / JDG) used by the application and the content of these caches.

## Caches manipulated by Microservice A

The caches are:

* `players` associating the player id (UUID as string) to the Player POJO (https://github.com/rhdemo/scavenger-hunt-microservice/blob/master/src/main/java/me/escoffier/keynote/Player.java). We can expect lots of player there probably > 1000. Notice that this cache has a lot of writes as every time a player scores, the value is updated.

* `tasks` storing the tasks. This is a fairly small cache containing the tasks (`taskId` -> task content as a JSON string). Replication is a key factor on this one because any node can add / update a task and this triggers an event every where to push the new set of tasks to all mobile phones.

* `active` is counting the number of active players. itâ€™s just associating the player id to tge cloud name, the size being 
the number of active players.

* `txs` stores all the request made by the players. It associates a transaction id (generated by the mobile application) to a json object (encoded as a string). This json object contains various data such as the `playerId`, `taskId`, `transactionId`, and the picture metadata. This last entry can be a few Kb.

Notice that when the picture is uploaded to Gluster, it uses the `transactionId` as file name. So functions can associate the the picture file to _request_ (`txs.get(transactionId)`).

## Caches manipulated by functions

Between the function B and C, a cache is used to communicate. This `objects` cache has the following schema:

```javascript
Key = transaction_id
Value = {
    objects: [
        "dog", "boat", "burr"
    ]
}
```

The objects is the list of _voc_ detected in the picture.

The function C retrieves the transaction from the the `txs` cache, the task from the `tasks` cache and computes the final 
score. 
 
 
